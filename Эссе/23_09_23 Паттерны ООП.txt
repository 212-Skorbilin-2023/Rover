Эссе
212 Скорбилин Илья
28 сентября 2023 г.
1 GOF паттерн
1.1 Что такое паттерн GOF
Паттерн GOF (Gang of Four) — это набор основных шаблонов проек-
тирования, описанных в книге «Design Patterns: Elements of Reusable
Object-Oriented Software» («Приемы объектно-ориентированного проек-
тирования. Паттерны проектирования») авторства Эриха Гаммы, Ричар-
да Хелма, Ральфа Джонсона и Джона Влиссидеса. Эта книга, изданная
в 1994 году, стала одной из наиболее известных и влиятельных книг в
области проектирования программного обеспечения.
Книга определяет 23 различных шаблона проектирования, которые
объединены в три категории:
1.2 Шаблоны создания (Creational Patterns)
1. Фабричный метод (Factory Method): определяет интерфейс для со-
здания объектов, позволяя подклассам выбирать класс для инстан-
цирования.
2. Абстрактная фабрика (Abstract Factory): предоставляет интерфейс
для создания семейств взаимосвязанных объектов без указания их
конкретных классов.
3. Строитель (Builder): предоставляет способ создания сложного объ-
екта шаг за шагом, не раскрывая его внутреннего представления.
4. Прототип (Prototype): определяет протокол создания объекта пу-
тем копирования уже существующего объекта вместо создания но-
вого экземпляра с нуля. Это позволяет создавать новые объекты,
избегая сложной логики инициализации.
5. Одиночка (Singleton): гарантирует, что класс имеет только один
экземпляр, и предоставляет глобальную точку доступа к этому эк-
земпляру.
1.3 Шаблоны структуры (Structural Patterns)
1. Адаптер (Adapter): преобразует интерфейс одного класса в дру-
гой, чтобы классы с несовместимыми интерфейсами могли рабо-
тать вместе.
2. Мост (Bridge): разделяет абстракцию от ее реализации, позволяя
им меняться независимо друг от друга. Это позволяет легко добав-
лять новые варианты реализации без изменения абстракции.
3. Компоновщик (Composite): обрабатывает отдельные объекты и груп-
пы объектов единообразно. Он позволяет создавать иерархические
древовидные структуры из объектов и работать с ними, как с еди-
ным объектом.
4. Декоратор (Decorator): динамически добавляет новую функциональ-
ность объекту путем оборачивания его в другой класс.
5. Фасад (Facade): предоставляет унифицированный интерфейс для
набора интерфейсов в сложной системе. Он упрощает взаимодей-
ствие с системой, скрывая ее сложность и предоставляя удобный
способ работы с ней.
6. Легковес (Flyweight): позволяет эффективно поддерживать множе-
ство мелких объектов, используя общие данные и сокращая исполь-
зование памяти.
7. Заместитель (Proxy): представляет объект-заместитель, контроли-
рующий доступ к другому объекту и предоставляющий дополни-
тельную функциональность.
1.4 Шаблоны поведения (Behavioral Patterns)
1. Цепочка обязанностей (Chain of Responsibility): позволяет созда-
вать цепочку объектов, которые последовательно обрабатывают за-
просы, передавая их по цепи, пока один из объектов не обработает
запрос или он не достигнет конца цепи.
2. Команда (Command): инкапсулирует запрос в виде объекта, позво-
ляя параметризовать клиентов с разными запросами, организовы-
вать историю команд и поддерживать отмену операций.
3. Итератор (Iterator): предоставляет способ последовательного до-
ступа к элементам коллекции без раскрытия ее внутренней струк-
туры.
4. Медиатор (Mediator): определяет объект, который инкапсулирует
способ взаимодействия между набором объектов, обеспечивая сла-
бую связь между ними. Это позволяет уменьшить зависимости меж-
ду объектами и сделать систему более гибкой.
5. Хранитель (Memento): позволяет зафиксировать и сохранить внут-
реннее состояние объекта так, чтобы его можно было восстановить
позже, без раскрытия деталей реализации.
6. Наблюдатель (Observer): определяет зависимость «один-ко-многим»
между объектами, чтобы при изменении состояния одного объекта
все зависящие от него объекты автоматически обновлялись.
7. Состояние (State): позволяет объекту изменять свое поведение при
изменении его внутреннего состояния.
8. Стратегия (Strategy): определяет семейство алгоритмов, инкапсу-
лирует каждый из них и делает их взаимозаменяемыми.
9. Шаблонный метод (Template Method): определяет скелет алгорит-
ма, перекладывая некоторые шаги на подклассы.
10. Посетитель (Visitor): позволяет добавлять новые операции к объ-
ектам без изменения их классов. Он достигается путем вынесения
операций в отдельные классы посетителей, которые могут быть
применены к объектам.
2 Паттерн Facade
2.1 Название и классификация паттерна
Фасад - паттерн, структурирующий объекты.
2.2 Назначение
Предоставляет унифицированный интерфейс вместо набора интерфей-
сов не- которой подсистемы. Фасад определяет интерфейс более высоко-
го уровня, кото- рый упрощает использование подсистемы.
2.3 Мотивация
Разбиение на подсистемы облегчает проектирование сложной системы в
целом. Общая цель всякого проектирования - свести к минимуму зависи-
мость подсистем друг от друга и обмен информацией между ними. Один
из способов решения этой задачи - введение объекта фасад, предостав-
ляющий единый упрощенный интер- фейс к более сложным системным
средствам.
Рассмотрим, например, среду программирования, которая дает приложени-
ям доступ к подсистеме компиляции. В этой подсистеме имеются та-
кие классы, как Scanner (лексический анализатор), Parser (синтаксиче-
ский анализатор), ProgramNode (узел программы), BytecodeStream (по-
ток байтовых кодов) и ProgramNodeBuilder (строитель узла програм-
мы). Все вместе они состав- ляют компилятор. Некоторым специализи-
рованным приложениям, возможно, понадобится прямой доступ к этим
классам. Но для большинства клиентов ком- пилятора такие детали, как
синтаксический разбор и генерация кода, обычно не нужны; им просто
требуется откомпилировать некоторую программу. Для таких клиентов
применение мощного, но низкоуровневого интерфейса подсистемы ком-
пиляции только усложняет задачу.
Чтобы предоставить интерфейс более высокого уровня, изолирую-
щий клиен- та от этих классов, в подсистему компиляции включен также
класс Compiler (компилятор). Он определяет унифицированный интер-
фейс ко всем возможнос- тям компилятора. Класс Compiler выступает
в роли фасада: предлагает простой интерфейс к более сложной подси-
стеме. Он «склеивает» классы, реализующие функциональность компи-
лятора, но не скрывает их полностью. Благодаря фаса- ду компилятора
работа большинства программистов облегчается. При этом те, кому ну-
жен доступ к средствам низкого уровня, не лишаются его.
2.4 Применимость
Используйте паттерн фасад, когда:
хотите предоставить простой интерфейс к сложной подсистеме. Ча-
сто подсис- темы усложняются по мере развития. Применение большин-
ства паттернов приводит к появлению меньших классов, но в большем
количестве. Такую подсистему проще повторно использовать и настра-
ивать под конкретные нужды, но вместе с тем применять подсистему
без настройки становится труднее. Фасад предлагает некоторый вид си-
стемы по умолчанию, устраи- вающий большинство клиентов. И лишь те
объекты, которым нужны более широкие возможности настройки, могут
обратиться напрямую к тому, что находится за фасадом;
между клиентами и классами реализации абстракции существует мно-
го за- висимостей. Фасад позволит отделить подсистему как от клиентов,
так и от других подсистем, что, в свою очередь, способствует повышению
степе- ни независимости и переносимости;
вы хотите разложить подсистему на отдельные слои. Используйте фа-
сад для определения точки входа на каждый уровень подсистемы. Если
подсисте- мы зависят друг от друга, то зависимость можно упростить,
разрешив под- системам обмениваться информацией только через фаса-
ды.
2.5 Структура
2.5.1 Участники
1. Facade (Compiler) - фасад: - «знает», каким классам подсистемы ад-
ресовать запрос; - делегирует запросы клиентов подходящим объ-
ектам внутри подсистемы;
2. Классы подсистемы (Scanner, Parser, ProgramNode и т.д.): - реа-
лизуют функциональность подсистемы; - выполняют работу, по-
рученную объектом Facade; - ничего не «знают» о существовании
фасада, то есть не хранят ссылок на него.
2.5.2 Отношения
Клиенты общаются с подсистемой, посылая запросы фасаду. Он переадресу-
ет их подходящим объектам внутри подсистемы. Хотя основную работу
выполня- ют именно объекты подсистемы, фасаду, возможно, придет-
ся преобразовать свой интерфейс в интерфейсы подсистемы. Клиенты,
пользующиеся фасадом, не имеют прямого доступа к объектам под- си-
стемы.
2.6 Результаты
У паттерна фасад есть следующие преимущества:
изолирует клиентов от компонентов подсистемы, уменьшая тем са-
мым чис- ло объектов, с которыми клиентам приходится иметь дело, и
упрощая рабо- ту с подсистемой;
позволяет ослабить связанность между подсистемой и ее клиентами.
Зачас- тую компоненты подсистемы сильно связаны. Слабая связанность
позволя- ет видоизменять компоненты, не затрагивая при этом клиентов.
Фасадь: помогают разложить систему на слои и структурировать зави-
симости между объектами, а также избежать сложных и циклических
зависимостей. Это мо- жет оказаться важным, если клиент и подсисте-
ма реализуются независимо Уменьшение числа зависимостей на стадии
компиляции чрезвычайно важ- но в больших системах. Хочется, конеч-
но, чтобы время, уходящее на пере- компиляцию после изменения клас-
сов подсистемы, было минимальным Сокращение числа зависимостей за
счет фасадов может уменьшить количе- ство нуждающихся в повтор-
ной компиляции файлов после небольшой моди- фикации какой-нибудь
важной подсистемы. Фасад может также упростить процесс переноса си-
стемы на другие платформы, поскольку уменьшается ве- роятность того,
что в результате изменения одной подсистемы понадобится изменять и
все остальные;
фасад не препятствует приложениям напрямую обращаться к клас-
сам под- системы, если это необходимо. Таким образом, у вас есть выбор
между прос- тотой и общностью.
3 Подход BCE (Boundary – Control – Entity)
Подход BCE (Boundary-Control-Entity – граница-управление-сущность)
представляет собой подход к объектному моделированию, основанный
на трехфакторном представлении классов.
В правильно спроектированной иерархии пакетов актер может взаи-
модействовать только с пограничными объектами из пакета BoundaryPackage,
объекты-сущности из пакета EntityPackage могут взаимодействовать толь-
ко с управляющими объектами из ControlPackage и управляющие объек-
ты из ControlPackage могут взаимодействовать с объектами любого типа.
Основным преимуществом подхода BCE является группирование клас-
сов в виде иерархических уровней. Это способствует лучшему понима-
нию модели и уменьшает ее сложность.
В языке UML для классов определены 3 основных стереотипа:
Boundary - Пограничные классы, классы, которые представляют ин-
терфейс между субъектом и системой.
Control - управляющие классы, описывают объект, который перехва-
тывает входные события инициированные пользователем и контролирует
выполнение бизнес-процессов.
Entity - сущности, которые описывают семантику сущностей. Для
каждого класса-сущности создают таблицу в БД, каждый атрибут ста-
новится полем БД.
4 Выбор STL контейнера
Я проанализировал варианты шаблонов, которые предоставляет STL, и
самым удобным из всех посчитал std::vector. Работая с ним, не прихо-
дится думать о правильном выделении памяти и прочих технических
трудностях. К тому же синтаксис работы с векторами очень похож на
синтаксис массивов, что опять же упрощает жизнь.
